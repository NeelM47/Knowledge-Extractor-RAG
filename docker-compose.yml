# docker-compose.yml

services:
  # Service 1: Neo4j Database
  neo4j:
    image: neo4j:5-community
    container_name: neo4j_db
    ports:
      - "7474:7474" # Web browser
      - "7687:7687" # Bolt driver
    volumes:
      - neo4j_data:/data
    environment:
      - NEO4J_AUTH=neo4j/your-password

  # Service 2: Redis (used by Django-Q)
  redis:
    image: redis:6-alpine
    container_name: redis_broker
    ports:
      - "6379:6379"

  # Service 3: Your Django Web Application (Gunicorn server)
  app:
    container_name: django_app
    build: . # Build from the Dockerfile in this directory
    command: gunicorn --bind 0.0.0.0:8000 --workers 1 --timeout 300 rag_webapp.wsgi:application
    volumes:
      - ./rag_webapp:/app # Mount local code for live-reloading during development
    ports:
      - "8000:8000"
    env_file:
      - ./rag_webapp/.env
    depends_on:
      - neo4j
      - redis

  # --- THIS IS THE NEW SERVICE ---
  # Service 4: Your Django-Q Background Worker
  worker:
    container_name: django_q_worker
    build: . # Build from the same Dockerfile as the app
    command: python manage.py qcluster # The command to start the worker
    volumes:
      - ./rag_webapp:/app # Also mount the code here so it stays in sync
    env_file:
      - ./rag_webapp/.env # The worker also needs access to the secrets
    depends_on:
      - redis # The worker depends on Redis to get its jobs

volumes:
  neo4j_data:
